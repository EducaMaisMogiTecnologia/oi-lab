#!/usr/bin/python3
# -*- coding: utf-8 -*-

import re
import os
from sys import argv, stdout
from collections import OrderedDict

# Logging modules
import logging
from systemd.journal import JournalHandler

# XCB window creation and drawing modules
import xcffib
from xcffib.xproto import (Atom, CW, ConfigWindow, PropMode, WindowClass)
import cairocffi

# Input device handling modules
import asyncio
import pyudev
from evdev import (InputDevice, ecodes)

# DBus modules (for communication with systemd-logind)
from pydbus import SystemBus

from time import (sleep, time)

THIS_SEAT_NAME = os.environ['XDG_SEAT']

MAX_SEAT_COUNT = 5
XORG_CONF_DIR = '/etc/X11/xorg.conf.d'
SCREENS_DIR = '/usr/share/oi-lab-multi-seat-config/screens'

bus = SystemBus()
logind = bus.get('.login1')

logger = logging.getLogger(argv[0])
logger.setLevel(logging.INFO)
logger.propagate = False
stdout_handler = logging.StreamHandler(stdout)
formatter = logging.Formatter(
    '%(asctime)s %(name)s[%(process)s] %(levelname)s %(message)s')
stdout_handler.setFormatter(formatter)
logger.addHandler(stdout_handler)
logger.addHandler(JournalHandler())


def find_root_visual(screen):
    """Find the xproto.VISUALTYPE corresponding to the root visual"""
    for i in screen.allowed_depths:
        for v in i.visuals:
            if v.visual_id == screen.root_visual:
                return v


class Window:
    def __init__(self):
        logger.info(f'Connecting to X server {os.environ["DISPLAY"]}')
        self.connection = xcffib.connect()
        self.id = self.connection.generate_id()

        screen = self.connection.get_setup().roots[self.connection.pref_screen]

        # Initialize window geometry as full screen size
        self.x = 0
        self.y = 0
        self.width = screen.width_in_pixels
        self.height = screen.height_in_pixels

        # Create window
        self.connection.core.CreateWindow(xcffib.CopyFromParent,
                                          self.id,
                                          screen.root,
                                          self.x, self.y,
                                          self.width, self.height,
                                          0,
                                          WindowClass.InputOutput,
                                          screen.root_visual,
                                          CW.BackPixel,
                                          [screen.white_pixel])

        # Show window
        self.connection.core.MapWindow(self.id)

        # Set Cairo surface and context
        xcb_surface = cairocffi.XCBSurface(self.connection,
                                           self.id,
                                           find_root_visual(screen),
                                           self.width,
                                           self.height)
        self.context = cairocffi.Context(xcb_surface)

        self.connection.flush()

    def set_wm_name(self, name):
        self.name = name
        self.connection.core.ChangeProperty(PropMode.Replace,
                                            self.id,
                                            Atom.WM_NAME,
                                            Atom.STRING,
                                            8,
                                            len(name),
                                            name)

    def load_image(self, image_path):
        self.connection.core.ClearArea(False, self.id, 0, 0, 0, 0)

        image_surface = cairocffi.ImageSurface.create_from_png(image_path)
        image_width = image_surface.get_width()
        image_height = image_surface.get_height()

        self.context.set_source_rgb(0, 0.533333333, 0.666666667)
        self.context.paint()

        self.context.set_source_surface(image_surface,
                                        (self.width-image_width) / 2,
                                        (self.height-image_height) / 2)
        self.context.paint()

        self.connection.flush()

    def write_message(self, message):
        self.context.select_font_face('sans-serif')
        self.context.set_font_size(24)
        self.context.set_source_rgb(1, 1, 1)
        self.context.move_to(10, 30)
        self.context.show_text(message)

        self.connection.flush()


class SeatNodelessDevice:
    def __init__(self, device):
        self.device_path = device.device_path
        self.sys_path = device.sys_path
        self.sys_name = device.sys_name
        self.seat_name = device.properties.get('ID_SEAT')

        parent = device.find_parent('pci')
        self.pci_slot = (parent.properties['PCI_SLOT_NAME'].lstrip('0000:')
                         if parent is not None else None)

    def attach_to_seat(self, seat_name):
        try:
            logind.AttachDevice(seat_name, self.sys_path, False)
            self.seat_name = seat_name
            logger.info('Device %s successfully attached to seat %s',
                        self.sys_path, seat_name)
        except Exception as error:
            logger.error('Failed to attach device %s to seat %s!',
                         self.sys_path, seat_name)
            logger.error(error)


class SeatDevice(SeatNodelessDevice):
    def __init__(self, device):
        super().__init__(device)
        self.device_node = device.device_node


class SeatHubDevice(SeatNodelessDevice):
    def __init__(self, device):
        super().__init__(device)
        self.product_id = device.attributes.asstring('idProduct')
        self.vendor_id = device.attributes.asstring('idVendor')


class SeatInputDevice(SeatDevice):
    def __init__(self, device):
        def is_root_hub(device):
            # all root hubs have the same manufacturer 1d6b (Linux Foundation)
            return device.attributes.asstring('idVendor') == '1d6b'

        def get_parent_hub(device):
            parent = device.find_parent('usb', device_type='usb_device')
            return (None
                    if (parent is None or is_root_hub(parent))
                    else (SeatHubDevice(parent)
                          if 'seat' in parent.tags
                          else get_parent_hub(parent)))

        super().__init__(device)

        # Only real USB hubs are allowed here!
        self.parent = get_parent_hub(device)

    def attach_to_seat(self, seat_name):
        if self.parent is not None:
            # If input device is connected to a USB hub,
            # attach the hub to the seat instead, so that
            # all other devices connected to the same hub
            # will be automatically attached to the same seat.
            self.parent.attach_to_seat(seat_name)
        else:
            super().attach_to_seat(seat_name)


def scan_keyboard_devices(context):
    devices = context.list_devices(subsystem='input', ID_INPUT_KEYBOARD=True)
    return [SeatInputDevice(device)
            for device in devices
            if device.device_node is not None]


def scan_mouse_devices(context):
    devices = context.list_devices(subsystem='input',
                                   ID_INPUT_MOUSE=True,
                                   sys_name='event*')
    return [SeatInputDevice(device)
            for device in devices
            if device.device_node is not None]


def main():
    context = pyudev.Context()
    all_keyboard_devices = scan_keyboard_devices(context)
    all_mouse_devices = scan_mouse_devices(context)

    # Here, configured_seats[seat_name] is
    # - True, if seat_name is seat0 or if there's at least one keyboard
    #   attached to seat_name, or
    # - False, otherwise.
    d = {
        seat_name: (seat_name == 'seat0'
                    or bool([device
                             for device in all_keyboard_devices
                             if device.seat_name == seat_name]))
        for (seat_name, _) in logind.ListSeats()
    }
    configured_seats = OrderedDict(sorted(d.items(), key=lambda item: item[0]))

    if configured_seats[THIS_SEAT_NAME]:
        # There's already a keyboard attached to this seat. We can exit now.
        return

    available_keyboard_devices = [device
                                  for device in all_keyboard_devices
                                  if device.seat_name is None]
    available_mouse_devices = [device
                               for device in all_mouse_devices
                               if device.seat_name is None]

    for device in available_keyboard_devices:
        logger.info('Available keyboard detected: %s -> %s',
                    device.device_node, device.sys_path)

        if device.parent is not None:
            logger.info('>>> Parent device: %s', device.parent.sys_path)

    for device in available_mouse_devices:
        logger.info('Available mouse detected: %s -> %s',
                    device.device_node, device.sys_path)

        if device.parent is not None:
            logger.info('>>> Parent device: %s', device.parent.sys_path)

    if (len(available_keyboard_devices) <= 1):
        # There are not enough keyboards available to attach to this seat
        # (if there's only one keyboard available, it will be reserved
        # to seat0), so we can exit now.
        return

    # Put this in a list, so it can be used globally in coroutines
    num_available_keyboards = [len(available_keyboard_devices)]

    # Initialize window
    window = Window()
    window.set_wm_name(f'oi-lab-multi-seat-window-{THIS_SEAT_NAME}')
    window.load_image(f'{SCREENS_DIR}/wait-loading.png')
    sleep(2)

    loop = asyncio.get_event_loop()

    async def read_all_keys(loop, keyboard):
        def refresh_screen(loop):
            seat_names = [*configured_seats.keys()]
            seat_states = [*configured_seats.values()]

            index = seat_names.index(THIS_SEAT_NAME)
            status = ''.join(f'{state:d}'
                             for state in seat_states[1:])
            window.load_image(
                f'{SCREENS_DIR}/seat{index}-{status}.png')

            remaining_seats = seat_states.count(False)
            window.write_message(
                f'Terminais restantes: {remaining_seats}        Teclados disponíveis: {num_available_keyboards[0]}')

            if configured_seats[THIS_SEAT_NAME]:
                loop.stop()

        refresh_screen(loop)

        # EV_KEY event values: 0 (release), 1 (press), or 2 (hold)
        async def read_key(keyboard):
            device = InputDevice(keyboard.device_node)

            async for event in device.async_read_loop():
                # pylint: disable=no-member
                if event.type == ecodes.EV_KEY and event.value == 1:
                    return event.code - ecodes.KEY_F1 + 1

        valid_key_pressed = False

        while not valid_key_pressed:
            key = await read_key(keyboard)
            valid_key_pressed = (1 <= key <= len(configured_seats)
                                 and not [*configured_seats.values()][key])

        logger.info(f'Key F{key} pressed on keyboard {keyboard.device_node}')
        key_seat_name = [*configured_seats.keys()][key]

        if (key_seat_name == THIS_SEAT_NAME):
            # This is the key we expect! Attach the keyboard to this seat.
            keyboard.attach_to_seat(key_seat_name)

        configured_seats[key_seat_name] = True
        num_available_keyboards[0] -= 1
        refresh_screen(loop)

    coroutines = (read_all_keys(loop, keyboard)
                  for keyboard in available_keyboard_devices)
    future = asyncio.gather(*coroutines)

    try:
        loop.run_until_complete(future)
    except RuntimeError as error:
        # It's OK to stop the loop if there still are
        # unfinished coroutines and this seat was just configured.
        if not configured_seats[THIS_SEAT_NAME]:
            raise error

    logger.info(f'Configuration finished for {THIS_SEAT_NAME}.')
    sleep(2)


if __name__ == '__main__':
    main()
